# 在棕地上工作：完整指南

## 重要提示

无论您计划使用现有项目开始何种代理编码，为代理生成上下文工件都至关重要。

如果使用 Claude Code，建议使用文档项目任务与架构师协作，系统地为您的代码库生成重要的关键工件。

或者，您可以利用像 Gemini 这样的 Web 代理来生成存储库的上下文信息和理解。如果它已经在 Github 上，您可以提供 Gemini 中的项目 URL，并使用代理来帮助团队 fullstack 或架构师特定的 gem 分析或记录项目。

如果您的项目太大，您也可以扁平化您的代码库 - 这可以使其更容易上传或与某些工具一起使用。您可以在 [Flattener 指南](./flattener.md) 中阅读有关可选工具的更多信息

## 什么是棕地开发？

棕地开发是指添加功能、修复错误或使现有软件项目现代化。与绿地（新）项目不同，棕地工作需要理解现有代码、尊重约束并确保新更改无缝集成，而不会破坏现有功能。

## 何时在棕地中使用 BMad

- 向现有应用程序添加重要的新功能
- 使遗留代码库现代化
- 集成新技术或服务
- 重构复杂系统
- 修复需要架构理解的错误
- 记录未记录的系统

## 何时不使用棕地流程

如果您刚刚使用 BMad 完成了 MVP，并且您想继续进行 MVP 后的工作，那么只需与 PM 交谈，并要求它与您合作创建一个新的 Epic 以添加到 PRD 中，拆分 Epic，使用架构师更新任何架构文档，然后从那里开始即可。

## 完整的棕地工作流程

从 Web 选项开始（可能节省一些成本，但可能带来更令人沮丧的体验）：

1. **按照 [<ins>用户指南 - 安装</ins>](user-guide.md#installation) 步骤在 Web 中设置您的代理。**
2. **生成整个代码库的“扁平化”单个文件** 运行：`npx bmad-method flatten`

从具有大型上下文和良好模型的 IDE 开始（对于最佳结果，在此过程中使用高质量模型非常重要）

1. 在 Claude Code 或类似的 IDE 中，选择 architect 代理，然后使用 \*document-project 任务。您需要确保验证并指导代理生成尽可能好的文档，以便 LLM 理解您的代码库，并且不包含任何误导或不必要的信息。

### 选择您的方法

#### 方法 A：PRD 优先（如果添加非常大的和复杂的新功能、单个或多个 Epic 或大规模更改，建议使用）

**最适合**：大型代码库、monorepo，或者当您确切知道要构建什么时

1. **首先创建 PRD** 以定义需求
2. **仅记录相关区域** 基于 PRD 需求
3. **更有效** - 避免记录未使用的代码

#### 方法 B：文档优先（适用于较小的项目）

**最适合**：较小的代码库、未知系统或探索性更改

1. **首先记录整个系统**
2. **创建 PRD** 具有完整的上下文
3. **更彻底** - 捕获所有内容

### 方法 A：PRD 优先工作流程（推荐）

#### 阶段 1：首先定义需求

**在 Gemini Web 中（上传您的 flattened-codebase.xml）：**

```bash
@pm
*create-brownfield-prd
```

PM 将：

- **询问您的增强** 要求
- **探索代码库** 以了解当前状态
- **识别需要文档的受影响区域**
- **创建具有明确范围的重点 PRD**

**关键优势**：PRD 识别出 monorepo/大型代码库的哪些部分实际上需要文档！

#### 阶段 2：重点文档

**仍在 Gemini Web 中，现在具有 PRD 上下文：**

```bash
@architect
*document-project
```

架构师将：

- **询问您的关注点** 如果未提供 PRD
- **提供选项**：创建 PRD、提供需求或描述增强
- **参考 PRD/描述** 以了解范围
- **专注于 PRD 或您的描述中标识的相关模块**
- **跳过不相关的区域** 以保持文档精简
- **为所有环境生成一份架构文档**

架构师创建：

- **一份综合架构文档** 遵循 fullstack-architecture 模板
- **涵盖单个文件中的所有系统方面**
- **易于复制并另存为** `docs/architecture.md`
- **如果需要，以后可以在 IDE 中进行分片**

例如，如果您说“向用户服务添加支付处理”：

- 仅记录：用户服务、API 端点、数据库模式、支付集成
- 创建重点源代码树，仅显示与支付相关的代码路径
- 跳过：管理面板、报告模块、不相关的微服务

### 方法 B：文档优先工作流程

#### 阶段 1：记录现有系统

**最佳方法 - 具有 1M+ 上下文的 Gemini Web**：

1. **转到 Gemini Web** (gemini.google.com)
2. **上传您的项目**：
   - **选项 A**：直接粘贴您的 GitHub 存储库 URL
   - **选项 B**：上传您的 flattened-codebase.xml 文件
3. **加载 architect 代理**：上传 `dist/agents/architect.txt`
4. **运行文档**：键入 `*document-project`

架构师将生成所有内容的综合文档。

#### 阶段 2：计划您的增强

##### 选项 A：完整的棕地工作流程（建议用于重大更改）

**1. 创建棕地 PRD**：

```bash
@pm
*create-brownfield-prd
```

PM 代理将：

- **分析阶段 1 中的现有文档**
- **从您那里请求具体的增强详细信息**
- **评估复杂性** 并推荐方法
- **为增强创建 Epic/Story 结构**
- **识别风险和集成点**

**PM 代理如何获取项目上下文**：

- 在 Gemini Web 中：已经具有阶段 1 文档中的完整项目上下文
- 在 IDE 中：将询问“请提供现有项目文档的路径”

**您将遇到的关键提示**：

- “您要添加什么具体的增强或功能？”
- “是否有任何现有系统或 API 需要与之集成？”
- “我们必须遵守哪些关键约束？”
- “您的时间表和团队规模是多少？”

**2. 创建棕地架构**：

```bash
@architect
*create-brownfield-architecture
```

架构师将：

- **审查棕地 PRD**
- **设计集成策略**
- **如果需要，计划迁移方法**
- **识别技术风险**
- **定义兼容性要求**

##### 选项 B：快速增强（适用于重点更改）

**对于没有完整 PRD 的单个 Epic**：

```bash
@pm
*create-brownfield-epic
```

何时使用：

- 增强已明确定义且已隔离
- 现有文档是全面的
- 更改不会影响多个系统
- 您需要快速周转

**对于单个 Story**：

```bash
@pm
*create-brownfield-story
```

何时使用：

- 错误修复或微小功能
- 非常孤立的更改
- 没有架构影响
- 清晰的实现路径

### 阶段 3：验证规划工件

```bash
@po
*execute-checklist-po
```

PO 确保：

- 与现有系统兼容
- 没有计划的重大更改
- 风险缓解策略到位
- 清晰的集成方法

### 阶段 4：保存和分片文档

1. 将您的 PRD 和架构另存为：docs/prd.md docs/architecture.md（注意：如果管理多个版本，您可以选择使用“brownfield-”作为前缀）
2. 分片您的文档：在您的 IDE 中

   ```bash
   @po
   shard docs/prd.md
   ```

   ```bash
   @po
   shard docs/architecture.md
   ```

### 阶段 5：过渡到开发

**遵循 [<ins>增强的 IDE 开发工作流程</ins>](enhanced-ide-development-workflow.md)**

## 棕地最佳实践

### 1. 始终首先记录

即使您认为您了解代码库：

- 运行 `document-project` 以捕获当前状态
- AI 代理需要此上下文
- 发现未记录的模式

### 2. 尊重现有模式

棕地模板专门查找：

- 当前的编码约定
- 现有的架构模式
- 技术约束
- 团队偏好

### 3. 计划逐步推出

棕地更改应：

- 支持功能标志
- 计划回滚策略
- 包括迁移脚本
- 保持向后兼容性

### 4. 彻底测试集成

#### 为什么测试架构师对于棕地至关重要

在棕地项目中，测试架构师 (Quinn) 成为您防止破坏现有功能的安全网。与您构建全新的绿地不同，棕地需要仔细验证新更改是否不会破坏已有的功能。

#### 棕地特定的测试挑战

测试架构师解决了独特的棕地复杂性：

| **挑战** | **测试架构师如何帮助** | **命令** |
| --- | --- | --- |
| **回归风险** | 识别哪些现有功能可能会中断 | `*risk` |
| **遗留依赖项** | 映射集成点和隐藏依赖项 | `*trace` |
| **性能下降** | 验证现有流程中没有速度减慢 | `*nfr` |
| **覆盖率差距** | 查找新更改涉及的未经测试的遗留代码 | `*design` |
| **重大更改** | 检测 API/合约冲突 | `*review` |
| **迁移安全** | 验证数据转换和回滚计划 | `*risk` + `*review` |

#### 完整的棕地测试架构师工作流程

##### 阶段 1：开发之前（风险与策略）

**对于棕地至关重要 - 首先运行这些：**

```bash
# 1. 风险评估（在创建 Story 后立即运行）
@qa *risk {brownfield-story}
# 识别：遗留依赖项、重大更改、集成点
# 输出：docs/qa/assessments/{epic}.{story}-risk-{YYYYMMDD}.md
# 棕地重点：
#   - 回归概率评分
#   - 受影响的下游系统
#   - 数据迁移风险
#   - 回滚复杂性

# 2. 测试设计（风险评估后）
@qa *design {brownfield-story}
# 创建：回归测试策略 + 新功能测试
# 输出：docs/qa/assessments/{epic}.{story}-test-design-{YYYYMMDD}.md
# 棕地重点：
#   - 需要回归测试的现有功能
#   - 集成测试要求
#   - 要维护的性能基准
#   - 功能标志测试场景
```

##### 阶段 2：开发期间（持续验证）

**在编码时监控集成健康状况：**

```bash
# 3. 需求跟踪（开发中期检查点）
@qa *trace {brownfield-story}
# 映射：新需求 + 现有功能保留
# 输出：docs/qa/assessments/{epic}.{story}-trace-{YYYYMMDD}.md
# 棕地重点：
#   - 必须仍然工作的现有功能
#   - 新/旧功能交互
#   - API 合约保留
#   - 缺少回归测试覆盖率

# 4. NFR 验证（在考虑“完成”之前）
@qa *nfr {brownfield-story}
# 验证：性能、安全性、可靠性未更改
# 输出：docs/qa/assessments/{epic}.{story}-nfr-{YYYYMMDD}.md
# 棕地重点：
#   - 性能回归检测
#   - 集成的安全影响
#   - 向后兼容性验证
#   - 遗留组件上的负载/压力
```

##### 阶段 3：代码审查（深度集成分析）

**全面的棕地审查：**

```bash
# 5. 完整审查（开发完成后）
@qa *review {brownfield-story}
# 执行：深度分析 + 主动重构
# 输出：
#   - Story 文件中的 QA 结果
#   - Gate 文件：docs/qa/gates/{epic}.{story}-{slug}.yml
```

审查专门分析：

- **API 重大更改**：验证是否维护了所有现有合约
- **数据迁移安全**：检查转换逻辑和回滚程序
- **性能回归**：与基准指标进行比较
- **集成点**：验证与遗留代码的所有接触点
- **功能标志逻辑**：确保正确的切换行为
- **依赖项影响**：映射受影响的下游系统

##### 阶段 4：审查后（Gate 更新）

```bash
# 6. GATE 状态更新（解决问题后）
@qa *gate {brownfield-story}
# 更新：修复后的质量 Gate 决策
# 输出：docs/qa/gates/{epic}.{story}-{slug}.yml
# 棕地注意事项：
#   - 可能放弃某些遗留代码问题
#   - 记录技术债务接受
#   - 跟踪迁移进度
```

#### 棕地特定的风险评分

测试架构师使用增强的风险评分进行棕地：

| **风险类别** | **棕地因素** | **对 Gate 的影响** |
| --- | --- | --- |
| **回归风险** | 集成点数量 × 代码年龄 | 分数 ≥9 = 失败 |
| **数据风险** | 迁移复杂性 × 数据量 | 分数 ≥6 = 关注 |
| **性能风险** | 当前负载 × 增加的复杂性 | 分数 ≥6 = 关注 |
| **兼容性风险** | API 使用者 × 合约更改 | 分数 ≥9 = 失败 |

#### 棕地测试标准

Quinn 对棕地强制执行其他标准：

- **回归测试覆盖率**：每个接触的遗留模块都需要测试
- **性能基准**：必须维持或改进当前指标
- **回滚程序**：每个更改都需要回滚计划
- **功能标志**：所有有风险的更改都在切换后面
- **集成测试**：覆盖所有遗留接触点
- **合约测试**：验证 API 兼容性
- **数据验证**：迁移正确性检查

#### 快速参考：棕地测试命令

| **场景** | **要运行的命令** | **顺序** | **为什么至关重要** |
| --- | --- | --- | --- |
| **向遗留代码添加功能** | `*risk` → `*design` → `*trace` → `*review` | 顺序 | 首先映射所有依赖项 |
| **API 修改** | `*risk` → `*design` → `*nfr` → `*review` | 顺序 | 防止破坏使用者 |
| **性能关键型更改** | `*nfr` 尽早且经常 → `*review` | 持续 | 立即捕获降级 |
| **数据迁移** | `*risk` → `*design` → `*trace` → `*review` → `*gate` | 完整周期 | 确保数据完整性 |
| **复杂系统中的错误修复** | `*risk` → `*trace` → `*review` | 重点 | 防止副作用 |

#### 与棕地场景集成

**特定于场景的指南：**

1. **遗留代码现代化**
   - 首先使用 `*risk` 映射所有依赖项
   - 使用 `*design` 计划绞杀无花果方法
   - 经常运行 `*trace` 以确保没有任何中断
   - `*review` 重点关注逐步迁移

2. **向 Monolith 添加功能**
   - `*risk` 识别集成复杂性
   - `*design` 计划隔离策略
   - `*nfr` 监控性能影响
   - `*review` 验证没有 Monolith 降级

3. **Microservice 提取**
   - `*risk` 映射服务边界
   - `*trace` 确保功能保留
   - `*nfr` 验证网络开销是否可接受
   - `*gate` 记录接受的权衡

4. **数据库模式更改**
   - `*risk` 评估迁移复杂性
   - `*design` 计划向后兼容的方法
   - `*trace` 映射所有受影响的查询
   - `*review` 验证迁移安全

### 5. 沟通更改

记录：

- 更改了什么以及原因
- 迁移说明
- 引入的新模式
- 弃用通知

## 常见的棕地场景

### 场景 1：添加新功能

1. 记录现有系统
2. 创建棕地 PRD，重点关注集成
3. **测试架构师的早期参与**：
   - 在草稿 Story 上运行 `@qa *risk` 以识别集成风险
   - 使用 `@qa *design` 计划回归测试策略
4. 架构强调兼容性
5. Story 包括具有测试要求的集成任务
6. **开发期间**：
   - 开发人员运行 `@qa *trace` 以验证覆盖率
   - 使用 `@qa *nfr` 监控性能影响
7. **审查阶段**：`@qa *review` 验证集成安全

### 场景 2：现代化遗留代码

1. 广泛的文档阶段
2. PRD 包括迁移策略
3. **测试架构师策略规划**：
   - `@qa *risk` 评估现代化复杂性
   - `@qa *design` 计划并行测试方法
4. 架构计划逐步转换（绞杀无花果模式）
5. Story 遵循增量现代化，包括：
   - 未触及的遗留代码的回归测试
   - 新/旧边界的集成测试
   - 每个阶段的性能基准
6. **持续验证**：在每次增量后运行 `@qa *trace`
7. **Gate 管理**：使用 `@qa *gate` 跟踪技术债务接受

### 场景 3：复杂系统中的错误修复

1. 记录相关子系统
2. 使用 `create-brownfield-story` 进行重点修复
3. **测试架构师风险评估**：运行 `@qa *risk` 以识别副作用潜力
4. 包括来自 `@qa *design` 输出的回归测试要求
5. **修复期间**：使用 `@qa *trace` 映射受影响的功能
6. **提交之前**：运行 `@qa *review` 进行全面验证
7. 测试架构师验证没有副作用，使用：
   - 副作用分析的风险概况（概率 × 影响评分）
   - 跟踪矩阵以确保修复不会破坏相关功能
   - NFR 评估以验证性能/安全性未更改
   - Gate 决策记录修复安全

### 场景 4：API 集成

1. 记录现有 API 模式
2. PRD 定义集成要求
3. **测试架构师合约分析**：
   - `@qa *risk` 识别重大更改潜力
   - `@qa *design` 创建合约测试策略
4. 架构确保一致的模式
5. **API 测试重点**：
   - 向后兼容性的合约测试
   - 新端点的集成测试
   - 增加的负载的性能测试
6. Story 包括 API 文档更新
7. **验证检查点**：
   - `@qa *trace` 映射所有 API 使用者
   - `@qa *nfr` 验证响应时间
   - `@qa *review` 确保没有重大更改
8. **Gate 决策**：记录任何接受的重大更改以及迁移路径

## 故障排除

### “AI 不理解我的代码库”

**解决方案**：使用指向关键文件的更具体路径重新运行 `document-project`

### “生成的计划不符合我们的模式”

**解决方案**：在规划阶段之前，使用您的特定约定更新生成的文档

### “小更改的样板代码太多”

**解决方案**：使用 `create-brownfield-story` 而不是完整的工作流程

### “集成点不明确”

**解决方案**：在 PRD 创建期间提供更多上下文，特别强调集成系统

## 快速参考

### 棕地特定的命令

```bash
# 记录现有项目
@architect *document-project

# 创建增强 PRD
@pm *create-brownfield-prd

# 创建具有集成重点的架构
@architect *create-brownfield-architecture

# 快速 Epic 创建
@pm *create-brownfield-epic

# 单个 Story 创建
@pm *create-brownfield-story
```

### 棕地的测试架构师命令

注意：下面显示了简短形式。完整命令：`*risk-profile`、`*test-design`、`*nfr-assess`、`*trace-requirements`

```bash
# 开发之前（规划）
@qa *risk {story}     # 评估回归和集成风险
@qa *design {story}   # 计划回归 + 新功能测试

# 开发期间（验证）
@qa *trace {story}    # 验证新旧覆盖率
@qa *nfr {story}      # 检查性能下降

# 开发之后（审查）
@qa *review {story}   # 深度集成分析
@qa *gate {story}     # 更新质量决策
```

### 决策树

```text
您是否拥有大型代码库或 Monorepo？
├─ 是 → PRD 优先方法
│   └─ 创建 PRD → 仅记录受影响的区域
└─ 否 → 您是否熟悉该代码库？
    ├─ 是 → PRD 优先方法
    └─ 否 → 文档优先方法

这是一个影响多个系统的重大增强吗？
├─ 是 → 完整的棕地工作流程
│   └─ 始终首先运行测试架构师 *risk + *design
└─ 否 → 这不仅仅是一个简单的错误修复吗？
    ├─ 是 → *create-brownfield-epic
    │   └─ 运行测试架构师 *risk 以获取集成点
    └─ 否 → *create-brownfield-story
        └─ 如果接触到关键路径，仍然运行 *risk

更改是否接触到遗留代码？
├─ 是 → 测试架构师是强制性的
│   ├─ *risk → 识别回归潜力
│   ├─ *design → 计划测试覆盖率
│   └─ *review → 验证没有中断
└─ 否 → 建议使用测试架构师
    └─ *review → 确保质量标准
```

## 结论

使用 BMad 方法进行棕地开发在修改现有系统时提供了结构和安全性。测试架构师成为您至关重要的安全网，使用风险评估、回归测试和持续验证来确保新更改不会破坏现有功能。

**棕地成功公式：**

1. **首先记录** - 了解已存在的内容
2. **尽早评估风险** - 在编码之前使用测试架构师 `*risk`
3. **计划测试策略** - 设计回归 + 新功能测试
4. **持续验证** - 在开发过程中检查集成健康状况
5. **全面审查** - 在提交之前进行深度分析
6. **果断地进行 Gate** - 记录质量决策

请记住：**在棕地中，测试架构师不是可选的 - 它是您防止破坏生产环境的保险单。**
